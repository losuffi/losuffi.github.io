<!DOCTYPE html>
<!--[if IE 8 ]><html class="ie ie8" lang="chinese (simplified)"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<html lang="chinese (simplified)">
<!--<![endif]-->
	<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <meta name="author" content="losuffi">


        <title>Losuffi's Blog - 使用预计算散射的方式实时基于物理的渲染云</title>


        <!-- CSS -->
        <link rel="stylesheet" href="/theme/css/style.css">

        <!-- Custom CSS -->
        	<link rel="stylesheet" href="/theme/css/colors/blue.css" id="colors">

        <!-- Code highlight color scheme -->
            <link href="/theme/css/code_blocks/darkly.css" rel="stylesheet">


        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->




        <meta name="tags" contents="图形" />

	                <meta property="og:locale" content="">
		<meta property="og:site_name" content="Losuffi's Blog">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="/shi-yong-yu-ji-suan-san-she-de-fang-shi-shi-shi-ji-yu-wu-li-de-xuan-ran-yun.html">
	<meta property="og:title" content="使用预计算散射的方式实时基于物理的渲染云">
	<meta property="og:description" content="">
	   <meta property="og:image" content="/images/guilherme-toti.jpg">
	<meta property="article:published_time" content="2019-02-27 23:52:36+01:00">
	</head>
	<body>
		<header id="header">
			<!-- Container -->
			<div class="container">
				<!-- Logo / Mobile Menu -->
				<div class="five columns">
					<div id="textlogo">
						<h1><a href="/">Losuffi's Blog</a></h1>
					</div>
				</div>
						<!-- Navigation
				================================================== -->
				<div class="eleven columns">

					<nav id="navigation" class="menu">
						<ul id="responsive">

							<li><a href="/">Home</a></li>


						</ul>
					</nav>
				</div>
			</div>
			<!-- Container / End -->
		</header>
		<!-- Header / End -->

		<!-- Breadcrumbs Container-->
		<div id="content-wrapper">
			<section id="titlebar">
				<!-- Container -->
				<div class="container">
				<div class="thirteen columns">
					<nav id="breadcrumbs">
						<ul>
							<li>You are here:</li>
							<li><a href="/">Home</a></li>
<li><a href="/category/ji-zhu-zhi-shi.html">技术知识</a></li>
<li>使用预计算散射的方式实时基于物理的渲染云</li>
						</ul>
					</nav>
				</div>
				</div>
				<!-- Container / End -->
			</section>

			<div class="container">
	<div class="twelve alt columns">
<article class="post" style="margin: 0; border: 0;">

	<div class="post-format">
		<div class="circle"><i class="icon-pencil"></i><span></span></div>
	</div>

	<section class="post-content">

		<header class="meta">
			<h2><a href="/shi-yong-yu-ji-suan-san-she-de-fang-shi-shi-shi-ji-yu-wu-li-de-xuan-ran-yun.html">使用预计算散射的方式实时基于物理的渲染云</a></h2>
			<ul>
				<li>By <a href="/author/losuffi.html">losuffi</a></li>
				<li>周三 27 二月 2019</li>
			</ul>
		</header>

		<h1>使用预计算散射的方式实时基于物理的渲染云</h1>
<blockquote>
<p>作者：&lt; GPU Pro 6 &gt; -----Egor </p>
</blockquote>
<p>​   真实感强烈的云，在游戏中一直是一种需求度很高的东西。云微观上是由会散射光的水分子构成的。在云的渲染中，难点是一束光从一片云射入到射出，要经历多次的散射，而要去模拟，抽样计算散射是比较昂贵的计算。因此，我们需要建立一个相对简单的计算模型来进行模拟。</p>
<!-- more -->

<p>​   使用面向摄像机的广告牌技术，可能是最普遍的做法了。但是广告牌是一个平面，这在很多视角下会丧失它的立体感。这种方法还有其他限制：光照效果是依靠美术去画的，这也会使它在很多角度看上去会失去真实感。除此之外，体积渲染也是一种渲染云的方法。为了避免锯齿，在同一个方向上通常需要采样多个采样点，这会造成性能瓶颈，尤其是在高分辨率的机器上（PS:体积渲染技术的问题）。当然还有更多，在物理上更精确的方法，使得表现效果更佳，但很难降低计算量，性能消耗较为巨大。</p>
<p>​   我们发现了一种新的基于物理的方法，且能有效率的渲染云。假定一朵云是由单个被我们称为“参考粒子”的粒子复制后通过扩张或者旋转构成的。在渲染之前，我们可能到达的摄像机位置，对视线上的方向，预计算其深度，和散射积分，并把数据保存。当运行时，我们加载数据，避免消耗大的步进光线采样或者slicing(极线采样)。比较从前的做法，我们做了如下的改进：</p>
<ul>
<li>一个更好的实时着色模型，基于预计算查表</li>
<li>一个使用3D网格计算云内光照衰减的改善方法</li>
<li>一个新的粒子生成算法</li>
<li>效率优化，包括GPU粒子的排序</li>
</ul>
<p>我们简要回顾了方法的主要概念，在这里我们主要讨论实现细节和改进。其他信息可去查看原始论文</p>
<h2>2 光线传输原理</h2>
<p>现在我们将简单介绍下在传播介质中光传输的主要概念。在传播媒介中，可以发现有三种现象：散射，吸收，以及射出。散射仅仅只改变光线传播的方向，吸收则是吸收光的能量，而射出则与之相反。这三个现象的强度我们用三个参数来进行描述：
</p>
<div class="math">$$
\beta_{Sc},\beta_{Ab},\beta_{Em}
$$</div>
<p>
吸收和散射都会减少介质中的光的能量。他的衰减参数:
</p>
<div class="math">$$
\beta_{Ex}=\beta_{Ab}+\beta_{Sc}
$$</div>
<p>
在云内部，吸收和射出是可以忽略不计的，即：
</p>
<div class="math">$$
\beta_{Em}=\beta_{Ab}=0
$$</div>
<p>
所以散射和衰减可以表述为同一个参数，用：
</p>
<div class="math">$$
\beta
$$</div>
<p>
表示。</p>
<p><img alt="2.1" src="https://i.imgur.com/qEJQSXn.png"></p>
<p>​   当一束光在云内部，由A点传输到B点的衰减为，我们称为光学深度(Optical Depth)：
</p>
<div class="math">$$
\begin{align}
&amp; \tau(A,B)=\int_A^B{\beta(P) \cdot ds} \\
&amp; 此时P=\frac{B-A}{\mid B-A \mid} ,s是当前的积分点
\end{align}
\tag{2.1}
$$</div>
<p>
​   为了得到单一光照的被散射后的强度，我们需要使用步进采样进行积分。每一个步进方向：
</p>
<div class="math">$$
L_{In}^{(1)}(C,\vec{v})=\int_{P0}^{P1}{\beta(P) \cdot L_{sun} \cdot e^{-\tau(Q,P)}\cdot e^{-\tau(P,P0)} \cdot P(\theta) \cdot ds}
\tag{2.2}
$$</div>
<p>
在这个等式中，C是当前摄像机的位置,<span class="math">\(\vec{v} $ 是视角方向。P0和P1是云对于视线的入口和出口两点，\)</span>L_{Sun}<span class="math">\( 是云外部的阳光强度，Q是阳光到达当前积分点P的点。\)</span>P(\theta)<span class="math">\( 是定义 散射出去多少能量的phase函数，\)</span>\theta<span class="math">\( 是观察方向PC和出射方向QP的夹角。注意，阳光在到达相机前，会衰减两次：即\)</span>e^{-\tau(Q,P)}<span class="math">\( 从阳光入口Q，到达散射点P，和\)</span>e^{-\tau(P,P0)}$ 从散射点P，到视线的入口P0</p>
<p>​   云的phase函数是非常复杂的。在实时渲染方法中，通常使用Cornette-Shanks方法来近似它：
</p>
<div class="math">$$
P(\theta) \approx \frac{1}{4\pi}\frac{3(1-g^2)}{2(2+g^2)}\frac{(1+\cos^2(\theta))}{(1+g^2-2g\cos(\theta))^{3/2}}
\tag{2.3}
$$</div>
<p>
​   使用单一散射强度<span class="math">\(L_{In}^{(1)}\)</span> ，我们可以计算二次散射<span class="math">\(L_{In}^{(n)}\)</span> ，然后三次散射也是如此。然后n次散射强度积分如下
</p>
<div class="math">$$
L_{In}^{(n)}(C,\vec{v})=\int_{P0}^{P1}{J^n(P,\vec{v}) \cdot L_{sun} \cdot e^{-\tau(P,P0)}\cdot ds}
\tag{2.4}
$$</div>
<p>
在公式2.4中<span class="math">\(J^n(C,\vec{v})\)</span> 是n-1阶散射的净强度</p>
<p><img alt="2.5" src="https://i.imgur.com/cALoW1I.png">
</p>
<div class="math">$$
J^n(P,\vec{v})=\beta(P) \cdot \int_\Omega L_{In}^{n-1}(P,\vec{w}) \cdot P(\theta) \cdot dw
\tag{2.5}
$$</div>
<p>
这是对P点的整个球面积分，<span class="math">\(\vec{w}\)</span>是入射方向，<span class="math">\(\theta $ 是\)</span>\vec{w} 和 \vec{v}$ 的夹角</p>
<p>总的散射强度计算如下：
</p>
<div class="math">$$
L_{In}(C,\vec{v})=\sum_{n=1}^{\infty}L_{In}^{n}(C,\vec{v})
\tag{2.6}
$$</div>
<p>
摄像机最终测量的辐射度是总散射强度和背景辐射强度之和：
</p>
<div class="math">$$
L(C,\vec{v})=L_{In}(C,\vec{v})+e^{-\tau(P_0,P_1)} \cdot L_B
\tag{2.7}
$$</div>
<h2>3 预计算解决方案</h2>
<p>​   上述等式，计算特别复杂，是不可能实时进行计算的。我们的解决这个问题的办法是，对参考体积粒子中的光传输进行建模，在预处理的时候求解出该粒子的所有方程式。而后，我们将结果保存起来，在实时着色时读取。</p>
<h3>3.1 光学深度(Opitical Depth)</h3>
<p>​   考虑一些知道密度分布的不均匀体积粒子。我们的目标是通过粒子为每一个摄像机位置和视图方向预计算公式（2.1）中的光学深度积分。为了描述每一条穿过粒子的射线，我们需要四维向量参数。前两个参数维度是方位角，即球坐标的两个角度<span class="math">\( \varphi_S \in [0,2\pi] ,\theta_S \in[0,\pi] $，表示入射点S，后面两个参数也是方位角，即\)</span>\varphi_\nu \in[0,2\pi],\theta_\nu \in [0,\frac{\pi}{2}]<span class="math">\( 表示在入口点处构建的切线空间中，视线的角度方向。该切线空间的构建中，轴指向球心。因为我们仅仅需要考虑穿过球的视线，所以另外一个角的最大值是 表示在入口点S处构建的切线空间中，视线的角度方向。该切线空间的构建中，z轴指向球心。因为我们仅仅需要考虑穿过球的视线，所以另外一个角的最大值是\)</span>\frac{\pi}{2} $。</p>
<p><img alt="4.3" src="https://i.imgur.com/2JuAXf2.png"></p>
<p>​   为了预计算光学深度积分，我们遍历所有的<span class="math">\(\varphi_S,\theta_S,\varphi_\nu,\theta_\nu\)</span> ，并利用公式2.1计算其积分值，在3.5中提供细节描述。</p>
<h3>3.2单次散射(Single Scattering)</h3>
<p>​   对比Opitical Depth，我们无法预计算不均匀粒子的散射，原因是，我们需要考虑光线方向，这就需要5个参数了，是不切实际的。所以我们预计算均匀分布球形颗粒中的散射。我们假定光的方向是正z轴，因为光场，相对光是对称的，所以我们可以舍弃 <span class="math">\(\varphi_S $ ,另一方面，为了计算公式2.5，我们需要知道整个体积的光场，而不仅仅是球表面的光场。因此，我们将从球心到起点的距离作为第四个参数。所以我们计算单次散射的参数为\)</span>\theta_S \in [0,\pi] ,\varphi_\nu \in[0,2\pi],\theta_\nu \in[0,\pi],r \in[0,1]。请注意因为光场需要覆盖整个球面角，所以 。请注意因为光场需要覆盖整个球面角，所以\theta_\nu的最大值是 的最大值是\pi$ </p>
<p>​   然后，是遍历所有参数值，使用2.2公式来预计算单次散射。因为假定了粒子是均匀的，<span class="math">\(\beta(P) \equiv \beta\)</span> 。阳光强度<span class="math">\(L_{Sun}，和phase函数P(\theta),被分解出来，单独计算\)</span> 细节在3.5.1提及。</p>
<h3>3.3多次散射(Multiple Scattering)</h3>
<p>​   我们使用与单次散射相似的参数对多次散射预处理。为了预计算多次散射，我们逐步执行以下的步骤：</p>
<ul>
<li>根据2.5，对所有参数项使用先前的阶数<span class="math">\(L_{In}^{n-1}\)</span> 去计算J(n)项</li>
<li>根据2.4，计算当前次散射<span class="math">\(L_{In}^{n}\)</span> </li>
<li>累加到当前散射序列和之中</li>
</ul>
<p>实现细节，在3.5.1中描述</p>
<p>​   在散射序列计算结束后，我们只保留表面上的光场，丢弃其余的数据。必须注意的是，相对于Optical Depth，在散射中，密集度与粒子半径不是线性相关的。在原始论文中，我们计算了许多密度的散射，并且在4D查找表中，对结果进行了编码，第四个参数是粒子密度的scale。后来发现，仅仅使用一个密度，也工作得挺好，而且简化了算法。</p>
<p>​   这一步将在3.5.3中进一步讨论</p>
<h3>3.4 Volume-Aware Blending(粒子融合)</h3>
<p>​   我们的云，由一系列的粒子构成，我们需要把他们混合成一个完整的传播媒介。实现这一目标的方法，通常是用alpha 融合。这种方法主要用于薄的物体，比如玻璃或者树叶。我们的粒子是体积渲染实体，没办法使用通用的alpha混合方式进行计算。为了解决这个问题，我们发现了一种新的技术，我们称为“Volume-Aware Blending”。这个技术的关键点是跟踪离摄像机最近的体积元素，针对每一个像素去混和每一个新的粒子。</p>
<p>​   算法第一步，清掉Closet element Buffer 和 back buffer。然后从后往前渲染体积粒子。针对当前最近的粒子，对每一个粒子进行测试。如果这个粒子比目前的最近粒子更接近相机，那么对最近粒子使用alpha混合，并将颜色写入back buffer，然后使新粒子取代最近粒子。如果新粒子比最近粒子远，那么新粒子就会混合到back buffer里头，最近粒子保持不变。</p>
<p>​   如果最近粒子与新粒子相交，那么事情就会变得复杂一些。首先把尾部融合进buffer，然后使用密度加权平均的方法融合相交部分的颜色
</p>
<div class="math">$$
T_i=e^{-(\rho_0+\rho_1)\cdot d_i \cdot \beta} \\
Ci=\frac{C_0 \cdot \rho_0+C_1 \cdot \rho_1}{\rho_0+\rho_1} \cdot(1-T_i)
\tag{3.1}
$$</div>
<p>
<span class="math">\(C_0,C_1是非alpha预乘颜色，\rho_1,\rho_2是密度，d_i是相交的长度\)</span> 。然后与头部的颜色进行混合后进buffer。</p>
<h3>3.5 实现</h3>
<p>例子是用C++的DXD11 的API实现的，全部的源代码可以在<a href="https://github.com/GameTechDev/CloudsGPUPro6">Github仓库中</a>找到</p>
<h4>3.5.1 预计算光传输路径</h4>
<p>​   我们将预计算数据做成一个3D一个4D的查找表。Optical Depth的积分保存在一个<span class="math">\(32 \times16\times32\times16(N_{\varphi s}=32,N_{\theta s}=16,N_{\varphi \nu}=32,N_{\theta \nu}=16)\)</span> 的一个8位LUT(lookup table)中。多次散射保存在一个<span class="math">\(32 \times 64 \times16(N_{\theta S}=32,N_{\varphi \nu}=64,N_{\theta \nu}=16)\)</span> 的16位 float的LUT中。第一个LUT需要0.25MB，第二个则需要64KB。注意与基础方法不同，我们不依赖预计算，而是使用别的方法来近似计算单次散射。</p>
<p>​   因为当前图形设备不支持4D纹理，我们只能使用3D纹理来进行取代。比如一张<span class="math">\(X \times Y \times Z \times W的纹理，我们可以储存成X \times Y \times Z \cdot W\)</span> 的3D纹理。我们对第四个坐标执行手动过滤。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define SAMPLE_4D(tex3DLUT,LUT_DIM, f4LUTCoords, fLOD, Result)\</span>
<span class="cp">{\</span>
<span class="cp">    float3 f3UVW0;                                             \</span>
<span class="cp">    f3UVW0.xy=f4LUTCoords.xy;\</span>
<span class="cp">    float fQSlice=f4LUTCoords.w * LUT_DIM.w -0.5;\</span>
<span class="cp">    float fQ0Slice =floor(fQSlice);\</span>
<span class="cp">    float fQWeight=fQSlice-fQ0Slice;\</span>
<span class="cp">    f3UVW0.z=(fQ0Slice+f4LUTCoords.z)/LUT_DIM.w;\</span>
<span class="cp">    </span><span class="cm">/* frac() assures wraparound filtering of w coordinate */</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3UVW1</span><span class="o">=</span><span class="n">frac</span><span class="p">(</span><span class="n">f3UVW0</span><span class="o">+</span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="n">LUT_DIM</span><span class="p">.</span><span class="n">w</span><span class="p">));</span>\
<span class="w">    </span><span class="n">Result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lerp</span><span class="p">(</span>\
<span class="w">        </span><span class="n">tex3DLUT</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="n">samLinearWrap</span><span class="p">,</span><span class="n">f3UVW0</span><span class="p">,</span><span class="n">fLOD</span><span class="p">),</span>\
<span class="w">        </span><span class="n">tex3DLUT</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="n">samLinearWrap</span><span class="p">,</span><span class="n">f3UVW1</span><span class="p">,</span><span class="n">fLOD</span><span class="p">),</span>\
<span class="w">        </span><span class="n">fQWeight</span>\
<span class="w">     </span><span class="p">);</span>\
<span class="p">}</span>
</code></pre></div>

<p>​   注意<span class="math">\(\varphi_S 和 \varphi_\nu\)</span> 坐标需要环绕滤波来避免伪影 。我们使用frac()函数，来让第四个坐标实现这个功能。也要注意z轴是不能使用环绕滤波模式的。</p>
<p>​   预计算进程可以被总结如下：</p>
<ul>
<li>预计算Optical Depth  积分</li>
<li>预计算单次散射将结果保存在32-bit的浮点型LUT</li>
<li>计算n次散射 从第2次到第N次：</li>
<li>计算<span class="math">\(J^n\)</span> 部分</li>
<li>计算<span class="math">\(L_{In}^n\)</span> 部分</li>
<li>累加<span class="math">\(L_{In}^n\)</span> 并存储到LUT中</li>
<li>复制多次散射中，位于球面的结果，保存到最终的16-bit的LUT中</li>
</ul>
<p>接下来对每一步的细节进行描述</p>
<h5>Optical depth.</h5>
<div class="highlight"><pre><span></span><code><span class="n">float2</span><span class="w">  </span><span class="nf">PreComputeOpticalDepthPS</span><span class="p">(</span><span class="n">SQuadVSOutput</span><span class="w"> </span><span class="n">IN</span><span class="p">)</span><span class="o">:</span><span class="n">SV_Target</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3StartPos</span><span class="p">,</span><span class="w"> </span><span class="n">f3RayDir</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//Convert lookup table 4D coordinate into the start position and view direction</span>
<span class="w">    </span><span class="n">OpticalDepthLUTCoordsToWorldParams</span><span class="p">(</span><span class="n">float4</span><span class="p">(</span><span class="n">ProjToUV</span><span class="p">(</span><span class="n">In</span><span class="p">.</span><span class="n">m_f2PosPS</span><span class="p">),</span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">f4Params</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span>
<span class="w">        </span><span class="n">f3StartPos</span><span class="p">,</span><span class="n">f3RayDir</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//Intersect the view ray with the unit sphere</span>
<span class="w">    </span><span class="n">float2</span><span class="w"> </span><span class="n">f2RayIsecs</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//x:first intersect length,y:second intersect length</span>
<span class="w">    </span><span class="c1">//f3StartPos is located exactly on the surface ; slightly move it inside the sphere to avoid       //precision issues</span>
<span class="w">    </span><span class="n">GetRaySphereIntersection</span><span class="p">(</span><span class="n">f3StartPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f3RayDir</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span><span class="n">f3RayDir</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.f</span><span class="p">,</span><span class="n">f2RayIsecs</span><span class="p">);</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3EndPos</span><span class="o">=</span><span class="n">f3StartPos</span><span class="o">+</span><span class="n">f3RayDir</span><span class="o">*</span><span class="n">f2RayIsecs</span><span class="p">.</span><span class="n">y</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fNumSteps</span><span class="o">=</span><span class="n">NUM_INTEGRATION_STEPS</span><span class="p">;</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3Step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f3EndPos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f3StartPos</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fNumSteps</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fTotalDensity</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">fStepNum</span><span class="o">=</span><span class="mf">0.5</span><span class="p">;</span><span class="w"> </span><span class="n">fStepNum</span><span class="o">&lt;</span><span class="n">fNumSteps</span><span class="p">;</span><span class="o">++</span><span class="n">fStepNum</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">f3CurrPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f3StartPos</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f3Step</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fStepNum</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">fDensity</span><span class="o">=</span><span class="n">ComputeDensity</span><span class="p">(</span><span class="n">f3CurrPos</span><span class="p">);</span>
<span class="w">        </span><span class="n">fTotalDensity</span><span class="o">+=</span><span class="n">fDensity</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fTotalDensity</span><span class="o">/</span><span class="n">fNumSteps</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>​   需要使用步进算法，一步一步计算。首先计算输入4D坐标，使用OpticalDepthLUTCoordsToWorldParams()函数得出的开始位置和射线方向。4D参数的前两维来自 像素位置，另外两维被存储在g_Attribs.f4Params.xy 变量中。然后继续得到射线与单位圆的交点以及射线离开单位圆的出口。GetRaySphereIntersection()函数中，参数是射线开始坐标，和方向，球的中心点以及半径。然后就是根据公式2.1计算积分。我们不存储积分值，而是存储归一化的平均值。平均值正好能保存在8-bit的的table中。Optical Depth在使用时 将保存的平均数乘上距离即可。ComputeDensity()函数作用是，用pos采样3Dnoise去计算当前点的密度。</p>
<h5>Single scattering</h5>
<p>预计算单次散射的片元着色器代码如下。注意单次散射的计算要包含整个体积，而不仅仅是在表面上。使用一张4DLUT储存结果。坐标的第4维编码保存的是到球心的距离，由g_Attribs.f4Params.y提供。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w">  </span><span class="nf">PrecomputeSingleSctrPS</span><span class="p">(</span><span class="n">SQuadVSOutput</span><span class="w"> </span><span class="n">In</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">SV_Target</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3EntryPoint</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDir</span><span class="p">;</span>
<span class="w">    </span><span class="n">ScatteringLUTToWorldParams</span><span class="p">(</span>
<span class="w">    </span><span class="n">float4</span><span class="p">(</span><span class="n">ProjToUV</span><span class="p">(</span><span class="n">In</span><span class="p">.</span><span class="n">m_f2PosPS</span><span class="p">),</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">f4Param</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span>
<span class="w">    </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">f4Param</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">f3EntryPoint</span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDir</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">float2</span><span class="w"> </span><span class="n">f2RayIsecs</span><span class="p">;</span>
<span class="w">    </span><span class="n">GetRaySphereIntersection</span><span class="p">(</span><span class="n">f3EntryPoint</span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="w"> </span><span class="p">,</span><span class="n">f2RayIsecs</span><span class="p">);</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3EndPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f3EntryPoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">f2RayIsecs</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fNumSteps</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NUM_INTEGRATION_STEPS</span><span class="p">;</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3Step</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">f3EndPos</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f3EntryPoint</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fNumSteps</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fStepLen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">(</span><span class="n">f3Step</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fCloudMassToCamera</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fParticleRadius</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">RefParticleRadius</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fInscattering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">fStepNum</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">fStepNum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">fNumSteps</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">fStepNum</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">f3CurrPos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f3EntryPoint</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f3Step</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fStepNum</span><span class="p">;</span>
<span class="w">        </span><span class="n">GetRaySphereIntersection</span><span class="p">(</span><span class="n">f3CurrPos</span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDir</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="mf">1.f</span><span class="w"> </span><span class="p">,</span><span class="n">f2RayIsecs</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">fCloudMassToLight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f2RayIsecs</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fParticleRadius</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">fAttenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="w"> </span>
<span class="w">        </span><span class="o">-</span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fAttenuationCoeff</span><span class="w"> </span><span class="o">*</span>
<span class="w">        </span><span class="p">(</span><span class="n">fCloudMassToLight</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">fCloudMassToCamera</span><span class="p">)</span>
<span class="w">        </span><span class="p">);</span>
<span class="w">        </span><span class="n">fInscattering</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fAttenuation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fScatteringCoeff</span><span class="p">;</span>
<span class="w">        </span><span class="n">fCloudMassToCamera</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fStepLen</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fParticleRadius</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fInscattering</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fStepLen</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fParticleRadius</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>​   算法是依据公式2.2实现的。注意phase函数<span class="math">\(P(\theta ) 和 阳光强度 L_{Sun}\)</span>被忽略了。因此着色器在每一步，需要去计算该式的积分:<span class="math">\(\beta(P) \cdot e^{-\tau(Q,P)} \cdot e^{-\tau(P,P_0)}\)</span> ，散射衰减因数<span class="math">\(\beta(P)\)</span>被看作是一个常数，由g_Attribs.fScatteringCoeff 变量提供。 我们使用的 <span class="math">\(\beta =0.07\)</span> 作为散射衰减系数。一个参考粒子（reference particle）的半径为200米。衰减<span class="math">\(e^{-\tau(Q,P )}\)</span> 是从当前点到光线与粒子球的交点入口的衰减。衰减<span class="math">\(e^{-\tau(P,P_0)}\)</span> 朝向摄像机部分的衰减是由云的所有mass表示的，使用fCloudMassToCamera变量进行累加。</p>
<h5>Multiple scattering</h5>
<p>在单次散射之后，我们计算了N=18次的多次散射。在这一阶段，我们使用了3张-4D 32-bit 的浮点型LUT：一张存储<span class="math">\(J^n\)</span>部分，一张存储当次散射<span class="math">\(L_{In}^n\)</span> 。第三张，则存储所有次散射混合的结果。</p>
<p>关于<span class="math">\(J^n\)</span> 的计算代码如下;</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">GatherScatteringPS</span><span class="p">(</span><span class="n">SQuadVSOutput</span><span class="w"> </span><span class="n">In</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="n">SV_Target</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3StartPos</span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDir</span><span class="p">;</span>
<span class="w">    </span><span class="n">ScatteringLUTToWorldParams</span>
<span class="w">    </span><span class="p">(</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">ProjToUV</span><span class="p">(</span><span class="n">In</span><span class="p">.</span><span class="n">m_f2PosPS</span><span class="p">),</span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">f4Param</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span>
<span class="w">        </span><span class="n">f3StartPos</span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRay</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDir</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">float3</span><span class="w"> </span><span class="n">f3LocalX</span><span class="p">,</span><span class="w"> </span><span class="n">f3LocalY</span><span class="p">,</span><span class="w"> </span><span class="n">f3LocalZ</span><span class="p">;</span>
<span class="w">    </span><span class="n">ConstructLocalFrameXYZ</span><span class="p">(</span><span class="o">-</span><span class="n">normalize</span><span class="p">(</span><span class="n">f3StartPos</span><span class="p">),</span><span class="w"> </span><span class="n">f3LightDir</span><span class="p">,</span><span class="w"> </span>
<span class="w">    </span><span class="n">f3LocalX</span><span class="p">,</span><span class="n">f3LocalY</span><span class="p">,</span><span class="n">f3LocalZ</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fJ</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fTotalSolidAngle</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fNumZenithAngles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCTR_LUT_DIM</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fNumAzimuthAngles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCTR_LUT_DIM</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fZenithSpan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PI</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fAzimuthSpan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">Zen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="n">Zen</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">fNumZenithAnles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">Zen</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">Az</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"> </span><span class="n">Az</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">fNumAzimuthAngles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">Az</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fZenith</span><span class="o">=</span><span class="w"> </span><span class="n">Zen</span><span class="o">/</span><span class="n">fNumZenithAngles</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fZenithSpan</span><span class="p">;</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fAzimuth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Az</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fNumAzimuthAngles</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fAzimuthSpan</span><span class="p">;</span>
<span class="w">            </span><span class="n">float3</span><span class="w"> </span><span class="n">f3CurrDir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetDirectionInLocalFrameXYZ</span><span class="p">(</span><span class="n">f3LocalX</span><span class="p">,</span><span class="w"> </span><span class="n">f3LocalY</span><span class="p">,</span><span class="w"> </span><span class="n">f3LocalZ</span><span class="p">,</span><span class="w"> </span><span class="n">fZenith</span><span class="p">,</span><span class="w"> </span><span class="n">fAzimuth</span><span class="p">);</span>
<span class="w">            </span><span class="n">float4</span><span class="w"> </span><span class="n">f4CurrDirLUTCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WorldParmasToScatteringLUT</span><span class="p">(</span><span class="n">f3StartPos</span><span class="p">,</span><span class="n">f3CurrDir</span><span class="p">,</span><span class="n">f3LightDir</span><span class="p">);</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fCurrDirSctr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="n">SAMPLE_4D</span><span class="p">(</span><span class="n">g_tex3DPrevSctrOrder</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">SCTR_LUT_DIM</span><span class="p">,</span><span class="w"> </span><span class="n">f4CurrDirLUTCoords</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">fCurrDirSctr</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="p">(</span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">f4Param</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">                </span><span class="n">fCurrDirSctr</span><span class="w"> </span><span class="o">*=</span><span class="n">HGPhaseFunc</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">f3CurrDir</span><span class="p">,</span><span class="n">f3LightDir</span><span class="p">),</span><span class="mf">0.9</span><span class="p">);</span>
<span class="w">            </span><span class="n">fCurrDirSctr</span><span class="w"> </span><span class="o">*=</span><span class="n">HGPhaseFunc</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">f3CurrDir</span><span class="p">,</span><span class="n">f3ViewDir</span><span class="p">),</span><span class="mf">0.7</span><span class="p">);</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fdZenithAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fZenithSpan</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fNumZenithAngles</span><span class="p">;</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fdAzimuthAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fAzimuthSpan</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fNumAzimuthAngles</span><span class="w"> </span><span class="o">*</span><span class="w">            </span><span class="n">sin</span><span class="p">(</span><span class="n">ZenithAngle</span><span class="p">);</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">fDiffSolidAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdZenithAngle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fdAzimuthAngle</span><span class="p">;</span>
<span class="w">            </span><span class="n">fTotalSolidAngle</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fDiffSolidAngle</span><span class="p">;</span>
<span class="w">            </span><span class="n">fJ</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">fCurrDirSctr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fDiffSolidAngle</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">fJ</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="w"> </span><span class="n">PI</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">fTotalSolidAngle</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">fJ</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>这部分代码，第一步是从4Dtexture中取到世界空间下的参数(3-6行)，与之前的代码类似。之后的步骤是构建局部转换矩阵（8-10行）。这个函数需要两个向量当作输入来构建正交基。第一个向量使用z轴，注意z轴是指向球心的。</p>
<p>​   然后构建两个循环，迭代zenith <span class="math">\( \theta\)</span> 和 azimuth <span class="math">\(\varphi\)</span> (18-19行) 。在每一步迭代中，着色器使用(<span class="math">\( \theta,\varphi $) 构建了采样方向。从转换这个方向为可采样的参数（26-28行）读取该方向上第n-1次散射(29-31行)。记得我们在计算单次散射的时候，没有计算phase 函数的。如果有必要，我们在这一步添加（32-34行）g_Attribs.f4Param.w的值是如果这是第二次散射则为1否则为0。之后我们用公式2.5计算phase 函数（35行），对于单次散射的各向异性系数我们使用0.9，而多次散射我们则使用0.7。最后计算\)</span>dw=d\theta \cdot d \varphi \cdot \sin{\theta}$ 部分(37-40行)</p>
<p>​   在<span class="math">\(J^n\)</span> 部分计算完成后，我们接着计算第n次散射。这部分与之前的单次散射十分类似，只需要把<span class="math">\(J^n\)</span> 读取出来，使之代替单次散射中的阳光衰减，我们还使用了梯度积分来提高准确性。</p>
<p>​   第三阶段，便是，取出各次散射，并进行加法混合，并将累积结果存储起来。</p>
<h4>3.5.2 粒子生成</h4>
<p>​   当我们渲染云的时候，我们想要能有效率的做LOD和对近处的云提供叫高的真实度。为了完成这个，我们使用了一个网格嵌套数据结构，这种结构的灵感来自几何图形贴图。每一个外环中的粒子是其内环中粒子的两倍大小，其粒子间距也是两倍。我们将这种结构称为一个单元网格。一个网格中的单元包含一个预定义数目的层数。每一个三维结构结果中的体素可能包含一个粒子。我们称这种结构是粒子格子。为了加速粒子生成和光照</p>
<p><img alt="Cell Grid and 3D lattice" src="https://i.imgur.com/dJyJb67.png"></p>
<p>我们维护了两个3D数据结构：云密度3D格子 和 光照衰减3D格子。这两个结构的分辨率每一维都是一个粒子格子的两倍，而且是使用3D贴图实现的。</p>
<p>粒子生成的过程如下：</p>
<ul>
<li>处理一张2D 单元网格，去建立一个有效非空单元列表，并计算每一个单元的属性</li>
<li>计算位于非空单元中每一个云密度格子中的每一个voxel</li>
<li>处理位于非空单元中每一个光照衰减格子中的每一个可见的voxel</li>
<li>处理粒子格子，为可见的单元且密度超过了阈值的粒子格子生成粒子。</li>
<li>处理粒子并储存光照信息</li>
<li>对粒子排序</li>
</ul>
<p>以上步骤的实施是通过一个compute shader去实现的。我们基于GPU去实现它，CPU不知道每一个Kernel，GPU需要多少的线程去运行。我们使用Dispatch Indirect() 函数来让GPU自己给自己分配。这个函数的参数和Dispatch()是一样的，但是这些参数是被储存在GPU Buffer中的，这就允许GPU控制它自己。我们接下来讨论，每一步的细节·</p>
<h5>Processing cell grid</h5>
<p>处理单元网格，是使用compute shader来完成的，为每一个单元分配一个线程。它负责基于摄像机的世界空间坐标计算每一个单元的中心点以及大小。使用计算出的单元中心位置，通过组合两个2Dnoise函数计算单元的基础密度。如果求出的结果超过阈值，那么就说明这个单元是合法的。着色器将所有合法的单元Append进Buffer中（g_ValidCellsAppendBuf）。最后能得到一个未排序的列表。如果单元在摄像机裁剪矩阵内，即是可见的，那么着色器将会把这些单元Append进另一个保存着所有可见的单元Buffer中(g_VisibleCellsAppendBuf)。</p>
<h5>Processing cloud density lattice</h5>
<p><img alt="Valid cells" src="https://i.imgur.com/MUB9UpB.png"></p>
<p>下一个阶段，我们需要处理在合法单元网格内的那些lattice中的voxel。为了计算这些，需要一定数量的GPU线程，我们执行了一个简单的单线程compute shader：</p>
<div class="highlight"><pre><span></span><code><span class="n">RWBuffer</span><span class="o">&lt;</span><span class="n">uint</span><span class="o">&gt;</span><span class="w"> </span><span class="n">g_DispatchArgsRW</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">register</span><span class="p">(</span><span class="n">u0</span><span class="p">);</span>
<span class="p">[</span><span class="n">numthread</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span><span class="w"> </span><span class="n">ComputeDispatchArgsCS</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">uint</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_GlobalCloudAttribs</span><span class="p">.</span><span class="n">uiDensityBufferScale</span><span class="p">;</span>
<span class="w">    </span><span class="n">g_DispatchArgsRW</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">g_ValidCellsCounter</span><span class="p">.</span><span class="n">Load</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">*</span>
<span class="w">                          </span><span class="n">g_GlobalCloudAttribs</span><span class="p">.</span><span class="n">uiMaxLayers</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">THREAD_GROUP_SIZE</span><span class="mi">-1</span><span class="p">)</span>
<span class="w">        </span><span class="o">/</span><span class="n">THREAD_GROUP_SIZE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>先前被写入buffer的元素可以用CopyStructureCount()函数拷贝进一个合适被读取的资源中。然后将先前作为UAV绑定到g_DispatchArgsRW的缓冲区传递给DispathIndirect()函数，以生成所需数量的线程。每一个线程读取g_ValidCellsUnorderedList Buffer中的合法单元，在上阶段被填满的cell内容，找出它在这个单元的位置。然后这个shader结合两个3Dnoise函数，创建一个单元密度的体积噪声。该噪声的幅度，随着高度降低，以产生典型的体积云形状，具有更宽的底部，和更窄的顶部。</p>
<h5>Light attenuation</h5>
<p>光照衰减是在每一个可见单元中的每一个voxel中被计算的。为了完成计算，我们需要分配一定数量的线程。使用与前阶段类似的方式，但是这次我们提供了具有合法性和可见性的单元buffer g_ValidCellsCounter变量。光照衰减是投一从voxel的中心朝光照方向的射线，通过密度lattice进行步进采样而计算出的。我们执行了16次步进。我们存储云衰减的mass系数，而不是直接存储光照衰减，是因为云衰减的mass能更好的被插值。</p>
<h5>Particle generation</h5>
<p>下一阶段，是处理cloud lattice中的有效可见的voxel，并为其中一些生成粒子。执行这一步，需要分配一定数目的线程。我们再次使用了简单的单线程compute shader。粒子生成器shader加载了云的密度，从密度lattice上，如果它不是0，那么就要创建粒子。shader随机的替换voxel中心的粒子，并加上一个随机的旋转和scale，以消除样式的重复性。着色器会将属性，比如粒子的坐标位置，密度，大小，写入粒子信息buffer中，并将粒子索引写入另一个append buffer中(g_VisibleParticlesAppendBuf)。</p>
<h5>Processing visible particles</h5>
<p>这一步，需要计算光照信息。特别是，我们在计算射到粒子中心的阳光颜色时，忽略了云的遮挡和周围天光的强度。我们也会采样光照衰减mass的贴图去计算光照遮挡。我们使用粒子表面的值去计算多次散射的衰减，用粒子中心的值去计算单次散射的衰减。此外，当计算多次散射的衰减时，我们让光照-衰减mass乘上一个0.25的系数去计算前向的强散射。</p>
<h5>Sorting</h5>
<p>在粒子能被正确渲染前，将粒子从后往前排序是最后的阶段了。在我们最开始的论文时，我们将粒子lattice的voxel排序是用CPU完成的，然后只有可见有效的voxel会从GPU中流出（用GPU做voxel的可见性和有效性判定）。这导致了一定数目的Drawbacks，首先他需要激活CPU-GPU通话。第二，由于随机的offset，粒子顺序和体素顺序可能有些微不同。但是主要的问题是，所有的voxel都会被排序，即使它们大部分是空的，这导致了CPU的overhead</p>
<p>我们现在将排序粒子完全用GPU去做，使用Satish et al 的合并排序算法（一个简化的合并算法程序）。我们开始时，将可见列表的粒子细分为128个粒子的子序列，并使用bitonic排序对每个子序列进行排序。然后我们执行合并操作，将已排好序的子序列合并成一个序列。当执行二进制搜索寻找其序号时，我们直接访问全局内存。因为需要排序的粒子相对较少通常不会超过50000，整个列表可以存入缓存，解释我们不适用共享内存，合并仍然非常有效。</p>
<p>重要的一点是，我们不知道GPU上生成了多少粒子以及我们需要执行多少次合并。因此我们执行了足够多数目的Pass，来对最大可能的粒子数目进行排序。当不需要再完成其他任务时，compute shader提前退出工作，性能成本时非常低的。</p>
<h4>3.5.3 渲染</h4>
<p>当前期的粒子生成，预处理和排序完成后，就可以进行渲染了。因为只有GPU知道我们生成了多少的粒子，所以我们使用DrawInstancedIndirect。它的使用与DrawInstance类似，只是它的参数，来自GPU Buffer。我们读取每一个应该可见的粒子，并从它的属性中读取数据，生成它的BoundingBox，最后将其送入光栅化流程。</p>
<p>在片元着色器中，我们对视线与粒子的bounding box求交，如果不相交，就Discard产生这条射线的这个像素。此外我们的着色模型是基于预计算的LUT的，正如下述代码。</p>
<div class="highlight"><pre><span></span><code><span class="c1">//Compute lookup coordinates</span>
<span class="n">float4</span><span class="w"> </span><span class="n">f4LUTCoords</span><span class="p">;</span>
<span class="n">WorldParamsToOpticalDepthLUTCoords</span><span class="p">(</span><span class="n">f3EntryPointUSSpace</span><span class="p">,</span><span class="w"> </span><span class="n">f3ViewRayUSSpace</span><span class="p">,</span><span class="w"> </span><span class="n">f4LUTCoords</span><span class="p">);</span>
<span class="c1">//Randomly rotate the sphere</span>
<span class="n">f4LUTCoords</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">ParticleAttrs</span><span class="p">.</span><span class="n">fRndAzimuthBias</span><span class="p">;</span>
<span class="c1">//Get the normalized density along the view ray</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fNormalizedDensity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.f</span><span class="p">;</span>
<span class="n">SAMPLE_4D_LUT</span><span class="p">(</span><span class="n">g_tex3DParticleDensityLUT</span><span class="p">,</span><span class="w"> </span><span class="n">OPTICAL_DEPTH_LUT_DIM</span><span class="p">,</span><span class="w"> </span><span class="n">f4LUTCoords</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">fNormalizedDensity</span><span class="p">);</span>
<span class="c1">//Compute actual cloud mass by multiplying the normalized</span>
<span class="c1">//density with ray length</span>
<span class="n">fCloudMass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fNormalizedDensity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fRayLength</span><span class="p">;</span>
<span class="n">fCloudMass</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">ParticleAttrs</span><span class="p">.</span><span class="n">fDensity</span><span class="p">;</span><span class="w"> </span>

<span class="c1">//Compute transparency</span>
<span class="n">fTransparency</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="w"> </span><span class="o">-</span><span class="n">fCloudMass</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fAttenuationCoff</span><span class="p">);</span>

<span class="c1">//Evaluate phase function for single scattering</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fCosTheta</span><span class="w"> </span><span class="o">=</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">f3ViewRayUSSpace</span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDirUSSpace</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">PhaseFunc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HGPhaseFunc</span><span class="p">(</span><span class="n">fCosTheta</span><span class="p">,</span><span class="w"> </span><span class="mf">0.8</span><span class="p">);</span>

<span class="n">float2</span><span class="w"> </span><span class="n">f2Attenuation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParticleLighting</span><span class="p">.</span><span class="n">f2SunLightAttenuation</span><span class="p">;</span>
<span class="c1">//Compute intensity of single scattering</span>
<span class="n">float3</span><span class="w"> </span><span class="n">f3SingleScattering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fTransparency</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ParticleLighting</span><span class="p">.</span><span class="n">f4SunLight</span><span class="p">.</span><span class="n">rgb</span><span class="w"> </span><span class="o">*</span>
<span class="n">f2Attenuation</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">PhaseFunc</span><span class="p">;</span>

<span class="c1">//Compute lookup coordinates for multiple scattering</span>
<span class="n">float4</span><span class="w"> </span><span class="n">f4MultSctrLUTCoords</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">WorldParamsToScatteringLUT</span><span class="p">(</span><span class="n">f3EntryPointUSSpace</span><span class="w"> </span><span class="p">,</span>
<span class="w">    </span><span class="n">f3ViewRayUSSpace</span><span class="p">,</span><span class="w"> </span><span class="n">f3LightDirUSSpace</span><span class="p">);</span>
<span class="c1">//Load multiple scattering from the lookup table</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fMultipleScattering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g_tex3DScatteringLUT</span><span class="p">.</span><span class="n">SampleLevel</span><span class="p">(</span><span class="w"> </span><span class="n">samLinearWrap</span><span class="p">,</span><span class="n">f4MultSctrLUTCoords</span><span class="p">.</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="n">float3</span><span class="w"> </span><span class="n">f3MultipleScattering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">fTransparency</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fMultipleScattering</span><span class="w"> </span><span class="o">*</span><span class="w"> </span>
<span class="w">    </span><span class="n">f2Attenuation</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ParticleLighting</span><span class="p">.</span><span class="n">f4SunLight</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>

<span class="c1">//Compute ambient light</span>
<span class="n">float3</span><span class="w"> </span><span class="n">f3EarthCentre</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fEarthRadius</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fEnttryPointAltitude</span><span class="w"> </span><span class="nf">length</span><span class="p">(</span><span class="n">f3EntryPointWS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f3EarthCentre</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fCloudBottomBoundary</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fEarthRadius</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fCloudAltitude</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fCloudThickness</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fAmbientStrength</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">(</span><span class="n">fEnttryPointAltitude</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fCloudBottomBoundary</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">g_Attribs</span><span class="p">.</span><span class="n">fCloudThickness</span><span class="p">;</span>
<span class="n">fAmbientStrength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="n">fAmbientStrength</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">float3</span><span class="w"> </span><span class="n">f3Ambient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">fTransparency</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">fAmbientStrength</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ParticleLighting</span><span class="p">.</span><span class="n">f4AmbientLight</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</code></pre></div>

<p>我们的第一步是计算密度,使用OpticalDepthLUT,我们随机的围绕垂直轴旋转一个角度，来减少重复度。f3EntryPointUSSpace和f3ViewRayUSSpace 是粒子空间下的起点和射线方向。（因为是单位圆空间，所以后缀是US）。接下来我们计算透明度</p>
<p>我们的实时渲染由三部分组成：单次散射，多次散射，和环境光。我们在第20-27行计算了单次散射。他是日照强度和日照衰减以及相位函数的乘积。因为单次散射在云密度低的地方最为明显，所以我们乘上一个透明度。</p>
<p>接下来我们计算多次散射。我们乘上了光照衰减强度。因为多次散射发生在云的密集区域，所以我们还要乘上不透明度（1-fTransprency）。</p>
<p>最后我们对环境光效果做一个近似。环境光的强度，在顶部边界是最强的，越往底部，越小。下图显示的是每一过程的结果</p>
<p><img alt="" src="https://i.imgur.com/3TKYlxZ.png"></p>
<blockquote>
<p>从左到右，依次是单次散射，多次散射，环境光，以及所有结果之和</p>
</blockquote>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
		    <div class="tags">
		        <p>tags: <a href="/tag/tu-xing.html">图形</a></p>
		    </div>

<div class="sharing">
</div>
<hr>

	</section>
	<div class="clearfix"></div>

</article>

	</div>

	<!-- Sidebar -->
	<div class="four columns">

		<!-- Categories -->
		<div class="widget">
			<h3 class="headline">Categories</h3><span class="line"></span><div class="clearfix"></div>
			<nav class="categories">
				<ul>
					    <li class="active"><a href="/category/ji-zhu-zhi-shi.html">技术知识</a></li>
					    <li><a href="/category/kai-fa-ri-zhi.html">开发日志</a></li>
					    <li><a href="/category/misc.html">misc</a></li>
					    <li><a href="/category/sheng-huo-ji-lu.html">生活记录</a></li>
				</ul>
			</nav>
		</div>
		
		<!-- Tags -->
		<div class="widget">
			<h3 class="headline">Tags</h3><span class="line"></span><div class="clearfix"></div>
			<nav class="tags">				    <a href="/tag/log.html">Log</a>
				    <a href="/tag/she-ying.html">摄影</a>
				    <a href="/tag/suan-fa.html">算法</a>
				    <a href="/tag/tu-xing.html">图形</a>
			</nav>
		</div>
	</div>
			</div>
			<!-- Container / End -->
		</div>
		<!-- Content Wrapper / End -->

		<div id="footer-bottom">
			<!-- Container -->
			<div class="container">
				<div class="eight columns">&copy;  || Blog powered by <a href="http://getpelican.com">Pelican</a></div>
					<div class="eight columns">
						<ul class="social-icons-footer">
								<li>
									<a href="#" class="tooltip top" title="Empty">
										<i class="icon-empty"></i>
									</a>
								</li>
							<li><a href="/None" class="tooltip top" title="RSS"><i class="icon-rss"></i></a></li>
						</ul>
					</div>
			</div>
			<!-- Container / End -->
		</div>
		<!-- Footer Bottom / End -->

	<!-- Javascripts -->
	<script src="/theme/js/jquery.min.js"></script>
	</body>
</html>